{"version":3,"sources":["webpack:///webpack/bootstrap 032b6656f0d1d729d6d6","webpack:///./lib/global.js","webpack:///./lib/board.js","webpack:///./lib/math_util.js","webpack:///./lib/landrun.js","webpack:///./lib/game.js","webpack:///./lib/player.js","webpack:///./lib/tail.js","webpack:///./lib/stack.js","webpack:///./lib/audio.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC/BsB;;AAEtB;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AAAA;AAAA;;AAEA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA,gCAAgC,EAAE,UAAU,EAAE,UAAU,EAAE;AAC1D;AACA;AACA;AACA;AACA,KAAK;AACL;AAAA;AAAA;;;;;;;;;;AClCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,uDAAuD,yBAAyB;AAChF,wDAAwD,kCAAkC;AAC1F;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,gCAAgC,EAAE;AAClE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,gCAAgC,gCAAgC,EAAE;AAClE;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD,mCAAmC,gCAAgC;AACnE;AACA;AACA;;AAEA,GAAG;;;AAGH,CAAC;;;;;;;;;;;;;AC1FD;AACA;AACA;;AAUC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kCAAkC;AACrD,kBAAkB,iCAAiC;AACnD;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,WAAW;AACpC,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,mBAAmB,oBAAoB;AACvC,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL,qBAAqB,iBAAiB;AACtC,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,WAAW,2CAA2C;AACtD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,cAAc;AACxC,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,yBAAyB,QAAQ;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;;;;;;;;;;;;ACjhBA;AAQC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,GAAG,WAAW,GAAG,WAAW;AACpE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,uBAAuB;AAClC;AACA;;AAEA;AACA,WAAW,uBAAuB;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,6CAA6C;AAC7C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC3LA;AACA;AACkC;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,8BAA8B,WAAW;AACzC,8BAA8B,QAAQ;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,QAAQ;;AAEpC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB,iCAAiC,QAAQ;;AAEzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kEAAkE,UAAU;;AAE5E;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,kDAAkD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtRA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;AClBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA","file":"landrun_bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 032b6656f0d1d729d6d6","export const BORDER = 10;\nexport const BOARD_SIZE = 60;\nexport const SQUARE_SIZE = 20;\nexport const SPEED = 5;\nexport const FRAME = 24;\nexport const SCORE_HEIGHT = 30;\nexport const SHADOW_SIZE = 3;\nexport const MIN_SQ = 6;\nexport const MAX_SQ = 53;\nexport const WIN_PER = 1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/global.js\n// module id = 0\n// module chunks = 0","class Board {\n  constructor(size, update) {\n    this.grid = new Array(size);\n    this.size = size;\n    this.update = update;\n  }\n\n  get(row, col) {\n    return this.grid[row] && this.grid[row][col];\n  }\n\n  set(row, col, value) {\n    if (!this.grid[row]) {\n      this.grid[row] = new Array(this.size);\n    }\n\n    const before = this.grid[row][col];\n    this.grid[row][col] = value;\n\n    if (typeof this.update === \"function\") {\n      this.update(row, col, before, value);\n    }\n\n    return before;\n  }\n\n  isOutOfBounds(row, col) {\n    return row < 0 || row >= this.size || col < 0 || col >= this.size;\n  }\n}\n\nexport default Board;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/board.js\n// module id = 1\n// module chunks = 0","import { SQUARE_SIZE } from './global';\n\nexport const randomNum = (min, max) => {\n  const minCeil = Math.ceil(min);\n  const maxFloor = Math.floor(max);\n  return Math.floor(Math.random() * (maxFloor - minCeil)) + minCeil;\n};\n\nexport const squaresIntersect = (a, b) => {\n  if (a < b) {\n    return b < a + SQUARE_SIZE;\n  } else {\n    return a < b + SQUARE_SIZE;\n  }\n};\n\nexport const randomColor = () => {\n  const hexDigits = \"0123456789ABCDEF\";\n\n  let color = \"#\";\n  for (let i = 0; i < 6; i ++) {\n    color += hexDigits[Math.floor((Math.random() * 16))];\n  }\n\n  return color;\n};\n\nexport const hexToRgb = (hex) => {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n    } : null;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/math_util.js\n// module id = 2\n// module chunks = 0","import Game from './game';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  var config = {\n    apiKey: \"AIzaSyBBNqha-ZUhUFLraH1abUaWjVMCWV8elkM\",\n    authDomain: \"landrun-66dd5.firebaseapp.com\",\n    databaseURL: \"https://landrun-66dd5.firebaseio.com\",\n    projectId: \"landrun-66dd5\",\n    storageBucket: \"scores\",\n    messagingSenderId: \"425401135146\"\n  };\n  firebase.initializeApp(config);\n\n  let game = null;\n  let scores = firebase.database().ref(\"scores\")\n\n  const gameOver = (won, playerName, score, completionTime) => {\n    const modal = won ? 'won' : 'loss';\n    game = null;\n    document.getElementById('nameDisplay').textContent = playerName;\n    document.getElementById(modal).className = 'game-modal-open';\n    if (won) {\n      const submitBtn = document.getElementById('submitscore')\n      const handleSubmit = () => {\n        firebase.database()\n          .ref(\"scores\")\n          .push()\n          .set({\n            username: playerName,\n            score: (score * 10000)\n          });\n        submitBtn.removeEventListener('click', handleSubmit);\n        submitBtn.textContent = 'Submitted!';\n      };\n      submitBtn.addEventListener('click', handleSubmit);\n      document.getElementById('area').textContent = `${(score * 100).toFixed(2)}% `;\n      document.getElementById('time').textContent = ` ${Math.floor(completionTime / 1000)} seconds`;\n      scores = firebase.database().ref(\"scores\");\n    }\n  };\n\n  const allModals = Array.from(document.getElementsByTagName('div'));\n  const btnListener = (e) => {\n    allModals.forEach(modal => { modal.className = 'game-modal'; });\n    document.getElementById(e.target.className).className = 'game-modal-open';\n  };\n\n  const allButtons = Array.from(document.getElementsByTagName('button'));\n  allButtons.forEach(button => button.addEventListener('click', btnListener));\n\n  const newGameBtns = Array.from(document.getElementsByClassName('start-game'));\n\n  newGameBtns.forEach(btn => btn.addEventListener('click', () => {\n    const playerName = document.getElementsByClassName('playerName')[0].value;\n    allModals.forEach(modal => { modal.className = 'game-modal'; });\n    game = new Game(7, playerName, gameOver);\n    })\n  );\n\n  const updateScores = () => {\n\n  }\n\n  updateScores();\n  scores.orderByChild(\"score\").limitToLast(10).on('value', (snapshot, highscores) => {\n    const scoresList = document.getElementById(\"scorelist\");\n    let currentScores = document.getElementsByClassName(\"scores-li\")\n    for (var i = currentScores.length - 1; i >= 0; i--) {\n      currentScores.item(i).remove();\n    }\n    highscores = [];\n      snapshot.forEach((childSnapshot) => {\n          highscores.push((childSnapshot.val()));\n      });\n      highscores = highscores.reverse();\n      for (var j = 0; j < highscores.length; j++) {\n        let score = document.createElement(\"li\");\n        scoresList.appendChild(score);\n        score.className = 'scores-li';\n        let name = document.createElement('span');\n        let scoreText = document.createElement('span');\n        name.textContent = `${highscores[j].username}`;\n        scoreText.textContent = `${Math.floor(highscores[j].score)}`;\n        score.appendChild(name);\n        score.appendChild(scoreText);\n      }\n\n  });\n\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/landrun.js\n// module id = 3\n// module chunks = 0","import Player from './player.js';\nimport Board from './board';\nimport * as MathUtil from './math_util';\n\nimport {\n  BORDER,\n  BOARD_SIZE,\n  SQUARE_SIZE,\n  SPEED,\n  FRAME,\n  SCORE_HEIGHT,\n  WIN_PER\n} from './global';\n\nimport * as SFX from './audio.js';\n\nclass Game {\n  constructor(numPlayers = 10, playerName = 'Player 1', handleGameOver) {\n    this.paused = false;\n    this.numPlayers = numPlayers;\n    this.won = false;\n    this.handleGameOver = handleGameOver;\n    this.drawLoop = this.drawLoop.bind(this);\n    this.listener = this.listener.bind(this);\n    this.directionListeners = this.directionListeners.bind(this);\n\n    this.playerName = playerName;\n    this.time = new Date();\n    this.initializeCanvas();\n    this.initializeBoard();\n    this.initializePlayers(numPlayers);\n    this.initializeStateVariables();\n    this.centerOnPlayer(this.user, this.offset);\n    if (window.SOUND === 'undefined') {\n      window.SOUND = false;\n    } else if (window.SOUND) {\n      SFX.track.play();\n    }\n    this.directionListeners();\n    this.drawLoop();\n  }\n\n  initializeCanvas() {\n    this.canvas = document.getElementsByTagName(\"canvas\")[0];\n    this.ctx = this.canvas.getContext('2d');\n\n    this.canvasWidth = this.canvas.width = 684;\n    this.canvasHeight = this.canvas.height = 484;\n\n    this.gameWidth = this.canvasWidth;\n    this.gameHeight = this.canvasHeight - SCORE_HEIGHT;\n  }\n\n  initializeBoard() {\n    const updateScore = (row, col, before, after) => {\n      if (before) { this.playerPortion[before.num]--; }\n      if (after) { this.playerPortion[after.num]++; }\n    };\n\n    this.grid = new Board(BOARD_SIZE, updateScore);\n  }\n\n  initializePlayers(numPlayers) {\n    const { randomNum } = MathUtil;\n    this.newPlayerFrames = [];\n    this.playerPortion = [];\n    this.allPlayers = [];\n    this.players = [];\n\n    for (let player = 0; player < numPlayers; player++) {\n      if (player === 0) {\n        this.makePlayer(true);\n      } else {\n        this.makeCPU();\n      }\n    }\n  }\n\n  makeCPU() {\n    const idx = this.players.length;\n    const { randomNum } = MathUtil;\n\n    let playerRow, playerCol, currentHeading;\n    const cpuStart = randomNum(0,4);\n    // 0 top, 1 right, 2 bottom, 3 left\n    switch (cpuStart) {\n      case 0: // top of board, row = 0, col random, drection 2\n        playerCol = randomNum(1, BOARD_SIZE -1);\n        playerRow = -1;\n        currentHeading = 2;\n        break;\n      case 1: // right of baord, col\n        playerCol = BOARD_SIZE + 1;\n        playerRow = randomNum(1, BOARD_SIZE -1);\n        currentHeading = 3;\n        break;\n      case 2:\n        playerCol = randomNum(1, BOARD_SIZE -1);\n        playerRow = BOARD_SIZE + 1;\n        currentHeading = 0;\n        break;\n      case 3:\n        playerCol = -1;\n        playerRow = randomNum(1, BOARD_SIZE -1);\n        currentHeading = 1;\n        break;\n    }\n\n    const options = {\n      posX: playerCol * SQUARE_SIZE,\n      posY: playerRow * SQUARE_SIZE,\n      currentHeading: currentHeading,\n      num: idx\n    };\n\n    const newPlayer = new Player(this.grid, options);\n    this.playerPortion[idx] = 0;\n    this.allPlayers[idx] = newPlayer;\n    this.players[idx] = newPlayer;\n  }\n\n  makePlayer(isPlayer) {\n    const idx = this.players.length;\n    const { randomNum } = MathUtil;\n\n    const playerRow = randomNum(8, BOARD_SIZE - 8);\n    const playerCol = randomNum(8, BOARD_SIZE - 8);\n    const options = {\n      posX: playerCol * SQUARE_SIZE,\n      posY: playerRow * SQUARE_SIZE,\n      currentHeading: randomNum(0, 4),\n      num: idx\n    };\n    const newPlayer = new Player(this.grid, options);\n    this.playerPortion[idx] = 0;\n    this.allPlayers[idx] = newPlayer;\n    this.players[idx] = newPlayer;\n\n    if (isPlayer) {\n      this.user = this.players[0];\n      // debugger;\n      if (this.playerName) {\n        this.user.name = this.playerName.slice(0,13);\n      }\n      this.user.cpu = false;\n\n      for (let dRow = -1; dRow <= 1; dRow++) {\n        for (let dCol = -1; dCol <= 1; dCol++) {\n          if (!this.grid.isOutOfBounds(dRow + playerRow, dCol + playerCol)) {\n            this.grid.set(\n              dRow + playerRow, dCol + playerCol, this.players[idx]\n            );\n          }\n        }\n      }\n    }\n  }\n\n  initializeStateVariables() {\n    this.frameCount = 0;\n    this.highscore = 0;\n    this.animateTo = [0, 0];\n    this.offset = [0, 0];\n    this.userPortion = 0;\n    this.lagPortion = 0;\n    this.portionSpeed = 0;\n    this.gameOver = false;\n\n  }\n\n  centerOnPlayer(player, pos) {\n    const xOff = Math.floor(player.posX - (this.gameWidth - SQUARE_SIZE) / 2);\n    const yOff = Math.floor(player.posY - (this.gameHeight - SQUARE_SIZE) / 2);\n    pos[0] = Math.max(\n      Math.min(\n        xOff, this.grid.size * SQUARE_SIZE + BORDER * 2 - this.gameWidth\n      ), 0);\n    pos[1] = Math.max(\n      Math.min(\n        yOff, this.grid.size * SQUARE_SIZE + BORDER * 2 - this.gameHeight\n      ), 0);\n  }\n\n  update() {\n    const {\n      animateTo,\n      offset,\n      lagPortion,\n      userPortion,\n      portionSpeed,\n      players,\n      newPlayerFrames,\n      grid,\n    } = this;\n\n    let delta;\n    let direction;\n    let magnitude;\n\n    for (let i = 0; i <= 1; i++) {\n      if (animateTo[i] !== offset[i]) {\n        delta = animateTo[i] - offset[i];\n        direction = Math.sign(delta);\n        magnitude = Math.min(SPEED, Math.abs(delta));\n        offset[i] += direction * magnitude;\n      }\n    }\n\n    if (lagPortion !== userPortion) {\n      delta = userPortion - lagPortion;\n      direction = Math.sign(delta);\n      magnitude = Math.min(Math.abs(portionSpeed), Math.abs(delta));\n      this.lagPortion += direction * magnitude;\n    }\n\n    const dead = [];\n    this.players = this.players.filter((val, idx) => {\n      if (!newPlayerFrames[val.num]) {\n        newPlayerFrames[val.num] = 0;\n      }\n      if (val.cpu) {\n        switch (val.heading) {\n          case 0:\n            if (val.row() < 0) {\n              // debugger;\n              val.dead = true;\n            }\n            break;\n          case 1:\n            if (val.col() > BOARD_SIZE) {\n              val.dead = true;\n            }\n            break;\n          case 2:\n            if (val.row() > BOARD_SIZE) {\n              val.dead = true;\n            }\n            break;\n          case 3:\n            if (val.col() < 0) {\n              val.dead = true;\n            }\n            break;\n        }\n      }\n      if (newPlayerFrames[val.num] < FRAME) {\n        newPlayerFrames[val.num]++;\n      } else {\n        if (!(this.gameOver || this.won)) {\n          val.move();\n        }\n      }\n      if (val.dead) {\n        dead.push(val);\n      }\n      return !val.dead;\n    });\n\n    if (this.players.length < this.numPlayers) {\n      this.makeCPU();\n    }\n\n    const removing = [];\n    for (let i = 0; i < players.length; i++) {\n      for (let j = i; j < players.length; j++) {\n        if (!removing[j] && players[j].tail.tailCollision(players[i])) {\n          if ((j === 0 || i === 0) && window.SOUND) {\n            SFX.collision.play();\n          }\n          removing[j] = true;\n        }\n        if (!removing[i] && players[i].tail.tailCollision(players[j])) {\n          if ((j === 0 || i === 0) && window.SOUND) {\n            SFX.collision.play();\n          }\n          removing[i] = true;\n        }\n\n        if (i !== j &&\n            MathUtil.squaresIntersect(players[i].startX, players[j].startX) &&\n          MathUtil.squaresIntersect(players[i].startY, players[j].startY)) {\n          if (grid.get(players[i].row, players[i].col) === players[i]) {\n            removing[j] = true;\n          } else if (grid.get(players[j].row, players[j].col) === players[j]) {\n            removing[i] = true;\n          } else {\n            const areaI = this.area(players[i]);\n            const areaJ = this.area(players[j]);\n\n            if (areaI === areaJ) {\n              removing[i] = removing[j] = true;\n            } else if (areaI > areaJ) {\n              removing[i] = true;\n            } else {\n              removing[j] = true;\n            }\n          }\n        }\n      }\n    }\n\n    this.players = this.players.filter((val, idx) => {\n      if (removing[idx])\n      {\n        dead.push(val);\n        val.eliminate();\n      }\n      return !removing[idx];\n    });\n\n    dead.forEach((val) => {\n      this.allPlayers[val.num] = undefined;\n    });\n    for (let row = 0; row < grid.size; row++) {\n      for (let col = 0; col < grid.size; col++) {\n        if (dead.indexOf(grid.get(row, col)) !== -1) {\n          grid.set(row, col, null);\n        }\n      }\n    }\n\n    if (!(this.gameOver || this.won)) {\n      this.userPortion = this.playerPortion[this.user.num] /\n      (BOARD_SIZE * BOARD_SIZE);\n    }\n    this.portionSpeed = Math.abs(userPortion - lagPortion) / FRAME;\n    this.centerOnPlayer(this.user, animateTo);\n  }\n\n  area(player) {\n    const xDest = player.col * SQUARE_SIZE;\n    const yDest = player.row * SQUARE_SIZE;\n\n    if (player.startX === xDest) {\n      return Math.abs(player.startY - yDest);\n    } else {\n      return Math.abs(player.startX - xDest);\n    }\n  }\n\n  drawGrid() {\n    const { ctx, offset, gameHeight, gameWidth, grid } = this;\n    ctx.fillStyle = \"#ffffff\";\n    ctx.fillRect(0, 0, SQUARE_SIZE * BOARD_SIZE, SQUARE_SIZE * BOARD_SIZE);\n\n    this.drawGridBorder();\n\n    const minRow = Math.max(Math.floor((offset[1] - BORDER) / SQUARE_SIZE), 0);\n    const minCol = Math.max(Math.floor((offset[0] - BORDER) / SQUARE_SIZE), 0);\n    const maxRow = Math.min(\n      Math.ceil((offset[1] + gameHeight) / SQUARE_SIZE), grid.size);\n    const maxCol = Math.min(\n      Math.ceil((offset[0] + gameWidth) / SQUARE_SIZE), grid.size);\n\n    for (let row = minRow; row < maxRow; row++) {\n      for (let col = minCol; col < maxCol; col++) {\n        const player = this.grid.get(row, col);\n        const x = col * SQUARE_SIZE;\n        const y = row * SQUARE_SIZE;\n        let baseColor;\n        let shadowColor;\n\n        if (player) {\n          baseColor = player.baseColor;\n          shadowColor = player.shadowColor;\n        } else {\n          continue;\n        }\n        this.ctx.fillStyle = baseColor;\n        this.ctx.fillRect(x, y, SQUARE_SIZE, SQUARE_SIZE);\n      }\n    }\n  }\n\n  drawGridBorder() {\n    const { ctx } = this;\n    ctx.fillStyle = 'darkgrey';\n    const gridWidth = SQUARE_SIZE * BOARD_SIZE;\n\n    ctx.fillRect(-BORDER, 0, BORDER, gridWidth);\n    ctx.fillRect(-BORDER, -BORDER, gridWidth + BORDER * 2, BORDER);\n    ctx.fillRect(gridWidth, 0, BORDER, gridWidth);\n    ctx.fillRect(-BORDER, gridWidth, gridWidth + BORDER * 2, BORDER);\n  }\n\n  drawLoop() {\n    // debugger;\n    const {\n      ctx,\n      canvasWidth,\n      canvasHeight,\n      offset,\n      players,\n      lagPortion\n    } = this;\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(-offset[0] + BORDER, -offset[1] + BORDER + SCORE_HEIGHT);\n    ctx.rect(offset[0] - BORDER, offset[1] - BORDER, canvasWidth, canvasHeight);\n    ctx.clip();\n    this.drawGrid();\n    players.forEach((player) => {\n      const fr = this.newPlayerFrames[player.num] || 0;\n      if (fr < FRAME) {\n        player.draw(ctx, fr / FRAME);\n      } else {\n        player.draw(ctx);\n      }\n    });\n\n    ctx.restore();\n\n    ctx.fillStyle = \"#727272\";\n    ctx.fillRect(0, 0, 684, SCORE_HEIGHT);\n\n    ctx.fillStyle = \"rgba(180, 180, 180, .3)\";\n    ctx.fillRect(0, 0, 684, SCORE_HEIGHT);\n\n    const barSize = Math.ceil((684 * this.lagPortion));\n    ctx.fillStyle = this.user.baseColor;\n    ctx.fillRect(0, 0, barSize, SCORE_HEIGHT);\n\n    ctx.fillStyle = \"#333\";\n    ctx.font = \"14px 'Press Start 2P'\";\n    ctx.fillText((lagPortion * 100).toFixed(1) + \"%\", 5+2, SQUARE_SIZE + 4);\n\n    ctx.fillStyle = \"white\";\n    ctx.font = \"14px 'Press Start 2P'\";\n    ctx.fillText((lagPortion * 100).toFixed(1) + \"%\", 5, SQUARE_SIZE + 2);\n\n    if (this.user.dead && !this.gameOver)\n    {\n      this.gameOver = true;\n      SFX.track.pause();\n      // you dead\n    }\n\n    this.frameCount++;\n    if (this.frameCount % 2 === 0) {\n      this.update();\n      if (this.userPortion > this.highscore) {\n        this.highscore = this.userPortion;\n      }\n    }\n\n    if (this.userPortion >= WIN_PER) this.won = true;\n\n    if (this.gameOver || this.won) {\n      document.removeEventListener('keydown', this.listener);\n      console.log(this.highscore);\n      if (this.highscore > 0.249999) {\n        return this.handleGameOver(true, this.user.name, this.highscore, (new Date() - this.time));\n      } else {\n        return this.handleGameOver(false, this.user.name);\n      }\n    } else if (this.paused) {\n      ctx.fillStyle = \"rgba(0, 0, 0, .8)\";\n      ctx.fillRect(0, 0, 684, 484);\n\n      ctx.fillStyle = \"whitesmoke\";\n      ctx.font = \"24px 'Press Start 2P'\";\n      ctx.fillText('paused', 270, 240);\n\n      window.cancelAnimationFrame(this.frame);\n    } else {\n      this.frame = window.requestAnimationFrame(this.drawLoop);\n    }\n  }\n\n  listener(e) {\n    if (this.user.dead) { return; }\n    let newHeading = -1;\n\n    switch (e.which) {\n      case 38:\n        newHeading = 0;\n        break;\n      case 39:\n        newHeading = 1;\n        break;\n      case 40:\n        newHeading = 2;\n        break;\n      case 37:\n        newHeading = 3;\n        break;\n      case 84:\n        window.SOUND = !window.SOUND;\n        if (window.SOUND) {\n          SFX.track.play();\n        } else {\n          SFX.track.pause();\n        }\n        return;\n      case 32:\n        this.paused = !this.paused;\n        if (this.paused) {\n          SFX.track.pause();\n        } else {\n          if (window.SOUND) {\n            SFX.track.play();\n          } else {\n            SFX.track.pause();\n          }\n        }\n        this.drawLoop();\n        e.preventDefault();\n        return;\n      default:\n        return;\n    }\n    e.preventDefault();\n    if (this.paused) return;\n    if (newHeading === this.user.currentHeading ||\n      ((newHeading % 2 === 0) ^ (this.user.currentHeading % 2 === 0))) {\n        if((this.user.currentHeading !== newHeading) && window.SOUND) {\n          SFX.turn.play();\n        }\n      this.user.heading = newHeading;\n    }\n  }\n\n  directionListeners() {\n    const { user } = this;\n    document.addEventListener('keydown', this.listener);\n  }\n}\n\nexport default Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game.js\n// module id = 4\n// module chunks = 0","import Tail from './tail';\nimport {\n  SQUARE_SIZE,\n  SPEED,\n  SHADOW_SIZE,\n  MIN_SQ,\n  MAX_SQ,\n  BOARD_SIZE\n} from './global';\nimport * as MathUtil from './math_util';\n\nimport * as SFX from './audio.js';\n\nclass Player {\n  constructor(grid, options) {\n    this.setColors();\n    this.move = this.move.bind(this);\n    this.row = this.row.bind(this);\n    this.col = this.col.bind(this);\n    // this.cpuKeepAlive = this.cpuKeepAlive.bind(this);\n\n    this.cpu = true;\n    this.grid = grid;\n    this.currentHeading = options.currentHeading;\n    this.heading = this.currentHeading;\n    this.dead = false;\n    this.num = options.num;\n    this.name = options.name || \"Player \" + (this.num + 1);\n    this.posX = options.posX;\n    this.posY = options.posY;\n    this.tail = this.initializeTail();\n  }\n\n  setColors() {\n    const hexColor = MathUtil.randomColor();\n    const rgbColor = MathUtil.hexToRgb(hexColor);\n    this.baseColor = hexColor;\n    this.shadowColor = `rgba(0, 0, 0, 0.4)`;\n    this.tailColor = `rgba(${rgbColor.r},${rgbColor.g},${rgbColor.b},0.4)`;\n  }\n\n  initializeTail() {\n    const tail = new Tail(this);\n    tail.adjust(this.row(), this.col());\n    return tail;\n  }\n\n  nearestInteger(positive, value) {\n    return positive ? Math.ceil(value) : Math.floor(value);\n  }\n\n  row() {\n    const { currentHeading, posY } = this;\n    return this.nearestInteger(currentHeading === 2, posY / SQUARE_SIZE);\n  }\n\n  col() {\n    const { currentHeading, posX } = this;\n    return this.nearestInteger(currentHeading === 1, posX / SQUARE_SIZE);\n  }\n\n  eliminate() {\n    this.dead = true;\n  }\n\n  draw(ctx) {\n    // if (this.cpu) this.cpuKeepAlive();\n    if (this.cpu) {\n      ctx.fillStyle = 'rgba(170, 44, 44, 0.1)';\n      switch (this.heading) {\n        case 0:\n        ctx.fillRect(this.posX, 0, SQUARE_SIZE, this.posY);\n        break;\n        case 1:\n        ctx.fillRect(this.posX, this.posY, (BOARD_SIZE * SQUARE_SIZE) - this.posX, SQUARE_SIZE);\n        break;\n        case 2:\n        ctx.fillRect(this.posX, this.posY, SQUARE_SIZE, (BOARD_SIZE * SQUARE_SIZE) - this.posY);\n        break;\n        case 3:\n        ctx.fillRect(0, this.posY, this.posX, SQUARE_SIZE);\n        // this.posX -= SPEED;\n        break;\n      }\n    }\n    this.tail.drawTail(ctx);\n\n    const offSetPosY = this.posY - SHADOW_SIZE;\n    ctx.fillStyle = this.shadowColor;\n    ctx.fillRect(this.posX, this.posY, SQUARE_SIZE, SQUARE_SIZE);\n\n    ctx.fillStyle = this.baseColor;\n    ctx.fillRect(this.posX, offSetPosY, SQUARE_SIZE, SQUARE_SIZE);\n    ctx.strokeRect(this.posX, offSetPosY, SQUARE_SIZE, SQUARE_SIZE);\n\n    if (!this.cpu) {\n      ctx.fillStyle = this.baseColor;\n      ctx.textAlign = \"center\";\n      ctx.fillText(this.name, (this.posX + SQUARE_SIZE / 2) + 2, this.posY - 10);\n      ctx.fillStyle = this.baseColor;\n      ctx.textAlign = \"center\";\n      ctx.fillText(this.name, this.posX + SQUARE_SIZE / 2, this.posY - 8);\n      ctx.fillStyle = '#666';\n      ctx.textAlign = \"center\";\n      ctx.fillText(this.name, (this.posX + SQUARE_SIZE / 2) + 1, this.posY - 9);\n    }\n  }\n\n  // cpuKeepAlive() {\n  //   // 0 is up, 1 is right, 2 is down, 3 is left\n  //   const headings = [0, 1, 2, 3];\n  //\n  //   if (this.lastMoveTime === null ||\n  //     (new Date() - this.lastMoveTime) > 1200 ) {\n  //       const newHeadings = headings;\n  //       newHeadings.splice(this.currentHeading, 1);\n  //       this.heading = newHeadings[MathUtil.randomNum(0,3)];\n  //       this.lastMoveTime = new Date();\n  //   }\n  //   const col = this.col();\n  //   const row = this.row();\n  //   if (col < MIN_SQ) {\n  //     this.heading = 0;\n  //     this.lastMoveTime = new Date();\n  //   }\n  //\n  //   if (row < MIN_SQ) {\n  //     this.heading = 1;\n  //     this.lastMoveTime = new Date();\n  //   }\n  //\n  //   if (col > MAX_SQ) {\n  //     this.heading = 2;\n  //     this.lastMoveTime = new Date();\n  //   }\n  //\n  //   if (row > MAX_SQ) {\n  //     this.heading = 3;\n  //     this.lastMoveTime = new Date();\n  //   }\n  // }\n\n  move() {\n    let heading = this.heading;\n    // if (this.cpu) this.cpuKeepAlive();\n\n    if (this.posX % SQUARE_SIZE !== 0 || this.posY % SQUARE_SIZE !== 0) {\n      heading = this.currentHeading;\n    } else {\n      this.currentHeading = heading;\n    }\n\n    switch (heading) {\n      case 0:\n        this.posY -= SPEED;\n        break;\n      case 1:\n        this.posX += SPEED;\n        break;\n      case 2:\n        this.posY += SPEED;\n        break;\n      case 3:\n        this.posX -= SPEED;\n        break;\n    }\n    const row = this.row();\n    const col = this.col();\n\n    if (this.grid.isOutOfBounds(row, col) && !this.cpu) {\n      if (window.SOUND) SFX.explode.play();\n      this.dead = true;\n    } else {\n      if (this.grid.get(row, col) === this) { // SAFE!\n        this.tail.fillTail(this.grid);\n        this.tail.adjust(row, col);\n        this.playerSafe = true;\n      } else if (\n        this.posX % SQUARE_SIZE === 0 &&\n        this.posY % SQUARE_SIZE === 0) {\n        this.playerSafe = false;\n        this.tail.addTail(heading);\n      }\n    }\n  }\n}\n\nexport default Player;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/player.js\n// module id = 5\n// module chunks = 0","import Board from './board';\nimport Stack from './stack';\nimport { BOARD_SIZE, SQUARE_SIZE } from './global';\n\nimport * as SFX from './audio.js';\n\nclass Tail {\n  constructor(player) {\n    this.player = player;\n    this.grid = player.grid;\n    this.tail = [];\n    this.tailMatrix = [];\n    this.prev = null;\n    this.startRow = 0;\n    this.startCol = 0;\n    this.lastRow = 0;\n    this.lastCol = 0;\n  }\n\n  visitTailMatrix(tailMatrix, row, col) {\n    if (!tailMatrix[row]) {\n      tailMatrix[row] = [];\n    }\n    tailMatrix[row][col] = true;\n  }\n\n  oldMove(direction) {\n    return ({\n      move: 1,\n      direction: direction\n    });\n  }\n\n  addTail(direction, count) {\n    if (count === undefined) { count = 1; }\n    if (!count || count < 0) { return; }\n\n    let prev = this.prev;\n    const row = this.lastRow;\n    const col = this.lastCol;\n\n    if (this.tail.length === 0) {\n      this.visitTailMatrix(this.tailMatrix, row, col);\n    }\n\n    if (!prev || prev.direction !== direction) {\n      prev = this.prev = this.oldMove(direction);\n      this.tail.push(prev);\n    } else {\n      prev.move += count;\n    }\n\n    for (let i = 0; i < count; i++) {\n      const pos = this.walk([this.lastRow, this.lastCol], null, direction, 1);\n      this.lastRow = pos[0];\n      this.lastCol = pos[1];\n      this.visitTailMatrix(this.tailMatrix, pos[0], pos[1]);\n    }\n  }\n\n  adjust(row, col) {\n    this.lastRow = this.startRow = row;\n    this.lastCol = this.startCol = col;\n    this.prev = null;\n    if (this.tail.length === 0) {\n      return;\n    } else {\n      const ret = this.tail;\n      this.tail = [];\n      this.tailMatrix = [];\n      return ret;\n    }\n  }\n\n  drawTail(ctx) {\n    if (!this.tail.length) { return; }\n\n    ctx.fillStyle = this.player.tailColor;\n\n    let lastDirection = -1;\n    let start = [this.startRow, this.startCol];\n\n    this.tail.forEach((tail) => {\n      const oppositeDirection = tail.direction === 0 || tail.direction === 3;\n      const back = start;\n\n      if (!oppositeDirection) {\n        start = this.walk(start, null, tail.direction, 1);\n      }\n\n      const finish = this.walk(start, null, tail.direction, tail.move - 1);\n\n\n      if (tail.move > 1) {\n        this.fillTailRect(ctx, start, finish);\n      }\n\n      if (lastDirection !== -1) {\n        this.drawCorner(ctx, back, lastDirection, tail.direction);\n      }\n\n      start = finish;\n\n      if (oppositeDirection) {\n        this.walk(start, start, tail.direction, 1);\n      }\n      lastDirection = tail.direction;\n    });\n\n    const currentDirection = this.player.currentHeading;\n    if (lastDirection === currentDirection) {\n      this.fillTailRect(ctx, start, start);\n    } else {\n      this.drawCorner(ctx, start, lastDirection, currentDirection);\n    }\n  }\n\n  drawCorner(ctx, cornerStart, last, current) {\n    if (last === 0 || current === 0) {\n      this.walk(cornerStart, cornerStart, 2, 1);\n    }\n\n    if (last === 3 || current === 3) {\n      this.walk(cornerStart, cornerStart, 1, 1);\n    }\n\n    const a = this.walk(cornerStart, null, current, 1);\n    const b = this.walk(a, null, last, 1);\n\n    const fold = new Path2D();\n    fold.moveTo(cornerStart[1] * SQUARE_SIZE, cornerStart[0] * SQUARE_SIZE);\n    fold.lineTo(a[1] * SQUARE_SIZE, a[0] * SQUARE_SIZE);\n    fold.lineTo(b[1] * SQUARE_SIZE, b[0] * SQUARE_SIZE);\n    fold.closePath();\n    for (let i = 0; i < 2; i++) {\n      ctx.fill(fold);\n    }\n  }\n\n  walk(from, to, direction, distance) {\n    to = to || [];\n    to[0] = from[0];\n    to[1] = from[1];\n\n    switch (direction) {\n      case 0:\n        to[0] -= distance;\n        break;\n      case 1:\n        to[1] += distance;\n        break;\n      case 2:\n        to[0] += distance;\n        break;\n      case 3:\n        to[1] -= distance;\n        break;\n    }\n\n    return to;\n  }\n\n  fillTailRect(ctx, start, end) {\n    let col = start[1] * SQUARE_SIZE;\n    let row = start[0] * SQUARE_SIZE;\n    let width = (end[1] - start[1]) * SQUARE_SIZE;\n    let height = (end[0] - start[0]) * SQUARE_SIZE;\n\n    if (width === 0) {\n      width += SQUARE_SIZE;\n    }\n    if (height === 0) {\n      height += SQUARE_SIZE;\n    }\n\n    if (width < 0) {\n      col += width;\n      width = -width;\n    }\n    if (height < 0) {\n      row += height;\n      height = -height;\n    }\n\n    ctx.fillRect(col, row, width, height);\n  }\n\n  onTail(coord) {\n    return this.tailMatrix[coord[0]] && this.tailMatrix[coord[0]][coord[1]];\n  }\n\n  fillTail(grid) { //BFS THAT TAILLLLLL\n    if (this.tail.length === 0) { return; }\n\n    const start = [this.startRow, this.startCol];\n    const visited = new Board(grid.size);\n    const points = [];\n\n    points.push(start);\n    while (points.length > 0) {\n      const coord = points.shift();\n      const row = coord[0];\n      const col = coord[1];\n\n      if (grid.isOutOfBounds(row, col) || visited.get(row, col)) { continue; }\n\n      if (this.onTail(coord)) {\n        visited.set(row, col, true);\n        grid.set(row, col, this.player);\n\n        this.fillClaimed(grid, row + 1, col, visited);\n        this.fillClaimed(grid, row - 1, col, visited);\n        this.fillClaimed(grid, row, col + 1, visited);\n        this.fillClaimed(grid, row, col - 1, visited);\n\n        points.push([row + 1, col]);\n        points.push([row - 1, col]);\n        points.push([row, col + 1]);\n        points.push([row, col - 1]);\n      }\n    }\n    if (window.SOUND) SFX.tailComplete.play();\n  }\n\n  fillClaimed(grid, initRow, initCol, visited) {\n    let points = [];\n    let filled = new Stack();\n    let surrounded = true;\n\n    points.push([initRow, initCol]);\n    while (points.length > 0) {\n      let coord = points.shift();\n      const row = coord[0];\n      const col = coord[1];\n\n      if (grid.isOutOfBounds(row, col)) {\n        surrounded = false;\n        continue;\n      }\n\n      if (visited.get(row, col) ||\n        this.onTail(coord) ||\n        grid.get(row, col) === this.player) {\n          continue;\n        }\n\n      visited.set(row, col, true);\n\n      if (surrounded) {\n        filled.push(coord);\n      }\n\n      points.push([row + 1, col]);\n      points.push([row - 1, col]);\n      points.push([row, col + 1]);\n      points.push([row, col - 1]);\n    }\n    if (surrounded) {\n      while (!filled.isEmpty()) {\n        let coord = filled.pop();\n        grid.set(coord[0], coord[1], this.player);\n      }\n    }\n\n    return surrounded;\n  }\n\n  tailCollision(otherTail) {\n    const { startRow, startCol, lastRow, lastCol, tailMatrix} = this;\n    const otherRow = otherTail.row();\n    const otherCol = otherTail.col();\n    return (\n      lastRow !== otherRow || lastCol !== otherCol) &&\n      (startRow !== otherRow || startCol !== otherCol) &&\n        Boolean(tailMatrix[otherRow] && tailMatrix[otherRow][otherCol]);\n  }\n}\n\nexport default Tail;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tail.js\n// module id = 6\n// module chunks = 0","class Stack {\n  constructor() {\n    this.store = [];\n  }\n\n  push(object) {\n    this.store.push(object);\n  }\n\n  pop() {\n    return this.store.pop();\n  }\n\n  isEmpty() {\n    return this.store.length === 0;\n  }\n}\n\nexport default Stack;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/stack.js\n// module id = 7\n// module chunks = 0","export const turn = new Audio('./assets/sounds/NFF-spit.wav');\nexport const collision = new Audio('./assets/sounds/NFF-low-wave.wav');\nexport const track = new Audio('./assets/sounds/Rhinoceros.mp3');\nexport const tailComplete = new Audio('./assets/sounds/NFF-money.wav');\nexport const explode = new Audio('./assets/sounds/NFF-magic-exploding.wav');\n\n\nturn.volume = 0.25;\ncollision.volume = 0.50;\ntrack.volume = 0.25;\ntailComplete.volume = 0.15;\nexplode.volume = 0.25;\n\ntrack.loop = true;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/audio.js\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}